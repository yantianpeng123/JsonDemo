package com.itmayiedu.day06;

/**
 * 垃圾回收机制概述：
 *  Java语言中最显著的一个特点就是引入了垃圾回收机制，使C++程序员最头疼的内存管理问题
 *  迎刃而解，它使得Java程序员在编程的时候不需要考虑内存管理，由于有个垃圾回收机制，
 *  Java中的对象不再有作用域的概念，只有对象的引用才有作用域，垃圾回收机制可以有效防止内存泄露，有效的使用空闲的内存
 *  ps：内存泄露，是指在该内存空间使用完毕之后未回收，再不涉及复杂的数据结构的一般情况下，Java的内存泄露表现为一个内存生命
 *  周期超出了程序需要它的时间长度，我们有时候也将起称为对象游离。
 *  垃圾回收机制的算法：
 *      引用计数法：
 *          给对象添加一个引用计数器，每当有一个地方引用它是，计数器的值就增加1，当引用失效时，计数器的值就减少1，任何时刻计数器都为0
 *          的对象就是不再被使用的。垃圾收集器将回收该对象使用的内存。
 *         优点：引用计数器可以很快的执行，交织在程序中，对程序中需要不被长时间打断的实时环境比较有利。
 *         缺点：无法检测出循环引用，如父对象有一个自对象的引用，子对象反过来引用父对象，这样他们的引用计数永远不可能为0，而且每次加减非常浪费内存。
 *      标记清楚算法：
 *          一个标记，一个清楚。标记：就是根据特定的算法标出内存中那些对象可以回收，那些对象还可以继续引用，
 *          标记指示回收，那就直接收掉。标记指示对象还能用，那就原地不动。
 *          缺点：标记和清楚不存在连续性，效率比较低，清楚之后存在大量的碎片。
 *      复制算法：
 *          主要用在新生代S0区和S1区
 *          S0和S1将可用内存按容量分成大小相等的两块。当这块内存使用完了，就将还存在的对象复制到另外内存上去，然后把使用过的内存空间
 *          一次清理掉。这样使得每次都是对其中的一块内存进行回收，内存分配时不用考虑内存碎片的复杂情况，只需要移动堆指针，按顺序即可，实现简单
 *          运行高效，
 *          复制算法的缺点：可使用的内存将为原来的一半。
 *          主要用在老年代里面。
 *      标记压缩：
 *          在标记清除的基础上做了优化，把存活的对象，压缩到内存的一端，而后进行垃圾清理。
 *          主要用在老年代里面。连续性不会产生碎片。
 *      分代算法：
 *          根据内存中对象的存活周期不同，将内存划分为几块，Java虚拟机中一般把内存划分为新生代和老年代，当新创建对象时，一般在新生代，
 *          分配内存空间，当新生代垃圾收集器回收几次后仍然存活的对象会被移动到老年代的内存中m，当大对象在新生代无法找到足够的连续内存时
 *          也直接在老年代中创建。
 *          对于新生代和老年代，新生代回收频率比较高，每次耗费时间比较短，但是对于老年代来说回收频率比较低，每次回收耗费的时间比较长，
 *          因此要尽量减少老年代的垃圾回收的次数。
 *          新生代和老年代
 *
 *    垃圾回收时的卡顿现象：
 *      垃圾回收的任务是识别和回收垃圾对象进行内存清理，为了让垃圾回收器可以更高效率的执行，大部分情况下，会要求系统
 *      进入一个停顿的状态，停顿的目的是为了终止所有的应用线程，只有啊这样系统才不会有新的垃圾产生，同时停顿保证了系统状态在
 *      某一个瞬间的一致性，也有利于更好的标记垃圾对象，因此咋垃圾回收时，都会产生应用程序的停顿。
 */
public class Demo01 {

    public static void main(String[] args) {
        Demo01 demo01 = new Demo01();
        demo01 =null;
        System.gc();
    }
    @Override
    protected void finalize() throws Throwable {
        //gc回收垃圾之前执行。
        System.out.println("垃圾回收机制。。。");
        super.finalize();
    }
}
